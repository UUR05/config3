; Тест 1: Число 15 (0x0000000F в 32 битах)
; Двоичное: 00000000 00000000 00000000 00001111
; Ожидаемый результат: 11110000 00000000 00000000 00000000 = 4026531840
LOAD_CONST 15
LOAD_CONST 100
BITREVERSE 0

; Тест 2: Число 240 (0x000000F0)
; Двоичное: 00000000 00000000 00000000 11110000
; Ожидаемый результат: 00001111 00000000 00000000 00000000 = 251658240
LOAD_CONST 240
LOAD_CONST 100
BITREVERSE 1

; Тест 3: Число 255 (0x000000FF)
; Двоичное: 00000000 00000000 00000000 11111111
; Ожидаемый результат: 11111111 00000000 00000000 00000000 = 4278190080
LOAD_CONST 255
LOAD_CONST 100
BITREVERSE 2

; Тест 4: Число 1 (минимальный бит)
; Двоичное: 00000000 00000000 00000000 00000001
; Ожидаемый результат: 10000000 00000000 00000000 00000000 = 2147483648
LOAD_CONST 1
LOAD_CONST 100
BITREVERSE 3

; Тест 5: Число 2147483648 (старший бит)
; Двоичное: 10000000 00000000 00000000 00000000
; Ожидаемый результат: 00000000 00000000 00000000 00000001 = 1
LOAD_CONST 2147483648
LOAD_CONST 100
BITREVERSE 4

; Проверка симметричности: применяем bitreverse дважды
; Должны получить исходное значение

; Применяем bitreverse к 42
LOAD_CONST 42
LOAD_CONST 200
BITREVERSE 0

; Читаем результат и применяем bitreverse еще раз
LOAD_CONST 200
READ_MEM 0
LOAD_CONST 200
BITREVERSE 1

; Результат должен быть 42
